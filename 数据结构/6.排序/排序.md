# 排序

## 排序的概念及运用

### 排序的概念

**排序**

所谓排序，就是使一串记录，按照其中的某个关键字的大小，递增或递减地排列操作。

**稳定性**

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中$r[i]=r[j]$，且$r[i]$在$r[j]$之前，而在排序后的序列中，$r[i]$仍在$r[j]$之前，则称这种排序算法是稳定的，否则称为不稳定的。

**内部排序**

待排序的记录全部放在内存中的排序。

**外部排序**

由于排序记录太多，不能同时放在内存中，根据排序过程的要求，在内外存之间多次交换数据的排序。

### 常见的排序算法

* 插入排序
  * 直接插入排序
  * 希尔排序
* 选择排序
  * 简单选择排序
  * 堆排序
* 交换排序
  * 冒泡排序
  * 快速排序
* 归并排序

```C{.line-numbers}
//排序实现的接口
//插入排序
void InsertSort(int* a,int n);
//希尔排序
void ShellSort(int* a,int n);
//选择排序
void SelectSort(int* a,int n);
//堆排序
void AdjustDown(int* a,int n,int root);
void HeapSort(int* a,int n);
//冒泡排序
void BubbleSort(int* a,int n);
//快速排序
void QuickSort(int* a,int left,int right);
//归并排序
void MergeSort(int* a,int n);
```

## 插入排序

### 直接插入排序

直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，从而得到一个新有序序列。

当插入第$i(i \geq 1)$个元素时，前面的array[0]~array[i-1]已经排好序，此时用array[i]的排序码与array[i-1]~array[0]的排序码按顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。

总结：
1. 元素越接近有序，直接插入排序算法的时间效率越高
2. 时间复杂度：$O(N^2)$
3. 空间复杂度：$O(1)$
4. 稳定性：稳定

### 希尔排序(Shell Sort)
希尔排序法又称缩小增量排序法，是D.L.Shell于1959年提出来的一种排序算法，在这之前排序算法的时间复杂度基本都是$O(N^2)$，希尔算法是突破这个时间复杂度的第一批算法之一。

希尔排序法的基本思想是将原本有大量记录数的记录进行分组。分成若干个子序列，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，再对全体记录进行一次直接插入排序。

总结：
1. 希尔排序是对直接插入排序的优化
2. 当gap>1时都是预排序，目的是让数组更接近于有序。当gap=1时，数组已经接近有序了，再整体进行一次直接插入排序
3. 希尔排序的时间复杂度需要进行推导，$O(N^{1.3})$
4. 稳定性：不稳定

## 选择排序

基本思想：每一次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的其实位置，直到全部待排序的数据元素排完。

### 简单选择排序算法

简单选择排序算法(Simple Selection Sort)就是通过$n-1$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i(1 \geq i \geq n)$个记录交换。

总结：
1. 直接选择排序易于理解，但效率不高，实际中很少使用
2. 时间复杂度：$O(N^2)$
3. 空间复杂度：$O(1)$
4. 稳定性：不稳定

### 堆排序

堆排序的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶点的根结点。将它与堆数组的末尾元素交换，此时末尾元素就是最大值。如此反复进行，便能得到一个有序序列。

#### 堆的两个特性

结构性：用数组表示的完全二叉树
有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)

总结：
1. 堆排序使用堆来选数，效率较高
2. 时间复杂度：$O(N*logN)$
3. 空间复杂度：$O(1)$
4. 稳定性：不稳定

## 交换排序

基本思想：所谓交换，就是根据序列中两个记录键值的比较结构来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。

### 冒泡排序

冒泡排序(Bubble Sort)是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

总结：
1. 冒泡排序是一种非常容易理解的排序
2. 时间复杂度：$O(N^2)$
3. 空间复杂度：$O(1)$
4. 稳定性：稳定

### 快速排序

快速排序是Tony Hoare设计出的一种二叉树结构的交换排序方法，其基本思想为，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序的目的。

总结：
1. 快速排序整体的综合性能和使用场景都是比较好的，所以叫快速排序
2. 时间复杂度：$O(N*logN)$
3. 空间复杂度：$O(logN)$
4. 稳定性：不稳定

## 归并排序

基本思想：归并排序(Merging Sort)就是利用归并的思想实现的排序算法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列长度为1，然后两两归并，得到$\lfloor \frac{N}{2} \rfloor$个查毒为2或1的有序子序列；再两两归并，如此重复，直至得到一个长度为n的有序子序列为止，这种排序方法称为2路归并排序。

总结：
1. 归并的缺点在于需要$O(N)$的空间复杂度，归并排序思考的更多的是解决再磁盘中的外排序问题
2. 时间复杂度：$O(N*logN)$
3. 空间复杂度：$O(N)$
4. 稳定性：稳定

## 排序算法复杂度及稳定性分析

|排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
|-|-|-|-|-|-|
|冒泡排序|$O(N^2)$|$O(N)$|$O(N^2)$|$O(1)$|稳定|
|简单选择排序|$O(N^2)$|$O(N^2)$|$O(N^2)$|$O(1)$|稳定|
|直接插入排序|$O(N^2)$|$O(N)$|$O(N^2)$|$O(1)$|稳定|
|希尔排序|$O(N*logN) \sim O(N^2)$|$N^{1.3}$|$O(N^2)$|$O(1)$|不稳定|
|堆排序|$O(N*logN)$|$O(N*logN)$|$O(N*logN)$|$O(1)$|不稳定|
|归并排序|$O(N*logN)$|$O(N*logN)$|$O(N*logN)$|$O(N)$|稳定|
|快速排序|$O(N*logN)$|$O(N*logN)$|$O(N^2)$|$O(logN) \sim O(N)$|不稳定|